<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Stone's Blog">
<meta property="og:url" content="http://shibing.github.io/index.html">
<meta property="og:site_name" content="Stone's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Stone's Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shibing.github.io/"/>





  <title> Stone's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Stone's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://shibing.github.io/2017/06/22/nginx互斥锁的实现与使用/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Bing Shi">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stone's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stone's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/22/nginx互斥锁的实现与使用/" itemprop="url">
                  nginx互斥锁的实现与使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-22T16:34:05+08:00">
                2017-06-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/06/22/nginx互斥锁的实现与使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/06/22/nginx互斥锁的实现与使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://shibing.github.io/2017/04/19/实现一个简单协程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Bing Shi">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stone's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stone's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/19/实现一个简单协程/" itemprop="url">
                  实现一个简单协程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-19T11:05:52+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/04/19/实现一个简单协程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/04/19/实现一个简单协程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近突然想实现一个简单的协程，一来是觉得比较有意思，二来是打算学习一下如何在 <code>gcc</code> 中嵌入汇编。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://shibing.github.io/2017/01/06/使用vagrant和nginx开发静态文件修改不生效问题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Bing Shi">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stone's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stone's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/06/使用vagrant和nginx开发静态文件修改不生效问题/" itemprop="url">
                  使用vagrant和nginx开发静态文件修改不生效问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-06T11:14:54+08:00">
                2017-01-06
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2017/01/06/使用vagrant和nginx开发静态文件修改不生效问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/06/使用vagrant和nginx开发静态文件修改不生效问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>最近使用 Vagrant 开发一个网站，里面跑的是 Nginx 服务器，一切工作都很正常，除了 CSS、JS 等静态文件的修改不能实时生效之外。当修改一个静态文件后，查看响应头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Server: nginx/1.10.2</div><div class="line">Date: Fri, 06 Jan 2017 03:20:44 GMT</div><div class="line">Content-Type: text/css</div><div class="line">Content-Length: 3217</div><div class="line">Last-Modified: Fri, 06 Jan 2017 03:20:42 GMT</div><div class="line">Connection: keep-alive</div><div class="line">ETag: &quot;586f0d0a-c91&quot;</div><div class="line">Accept-Ranges: bytes</div></pre></td></tr></table></figure>
<p>通过 <code>Last-Modified</code> 以及 <code>ETag</code> 字段可以看到 Nginx 确实探测到了修改，但是响应内容却依然是以前的，很是奇怪。</p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>后来通过 stackoverflow 找到了这个问题的原因，我的 Vagrant 底层用的是 VirtualBox, 而 vboxvfs 在使用 mmap 时会有一些问题，具体表现为在虚拟机之外修改文件后，虚拟机内以 mmap 方式打开文件的不能同步修改。而 Nginx 在 sendfile 选项开启后会通过 mmap 来加速文件的访问，自然就会有上面说的这个问题。</p>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>知道问题原因后，解决办法就很自然了，只要将 nginx 的 sendfile 选项关闭即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendfile off;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://shibing.github.io/2016/11/18/nginx的延迟关闭-lingering-close/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Bing Shi">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stone's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stone's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/18/nginx的延迟关闭-lingering-close/" itemprop="url">
                  nginx的延迟关闭
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-18T20:04:53+08:00">
                2016-11-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/11/18/nginx的延迟关闭-lingering-close/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/18/nginx的延迟关闭-lingering-close/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近业务方反馈线上 <code>Nginx</code> 经常会打出一些『奇怪』的 access 日志，奇怪之处在于这些日志的 <code>request_time</code> 值总是正好 <code>upstream_response_time</code> 的值大5秒，于是我就帮他们查看了一下导致这个问题的原因，本文记录一下最终调查的结论以及过程。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>首先给出产生该问题的原因，这样不愿意看细节的同学看完这段就可以结束阅读了。该问题是由 <code>Nginx</code> 的延迟关闭（<code>lingering close</code>）连接导致的。<code>Nginx</code> 为了能够平滑关闭连接，采用了延迟关闭，它的工作方式如下：<code>Nginx</code> 在给客户端发送完最后一个数据包后会首先关闭 <code>TCP</code> 连接的写端（<code>TCP</code> 是全双工协议，任何一端都即可读也可写），表示服务端不会再向客户端发送任何数据，但是不会立即关闭 <code>TCP</code> 连接的读端，而是等待一个超时，在超时到达后如果客户端还没有数据发来，<code>Nginx</code> 才会关闭TCP的读端，从而关闭整个连接，然后再输出日志。另一方面，<code>Nginx</code> 是在关闭连接后才输出日志，所以在输出日志之前响应早就发送给了用户，因此对业务几乎没有影响。但是这也会导致 <code>requset_time</code> 值变得不准确，使其失去统计意义，开启 <code>Keep-Alive</code> 可以部分解决这一问题。</p>
<h1 id="问题追踪"><a href="#问题追踪" class="headerlink" title="问题追踪"></a>问题追踪</h1><p>首先我们先来了解一下 <code>request_time</code> 与 <code>upstream_response_time</code> 这两个值在 <code>Nginx</code> 中是怎么定义的，它们的含义在 <code>Nginx</code> 手册中描述如下： </p>
<ul>
<li><code>request_time</code>：从接受到请求数据的第一个字节开始到发送完响应的最后一个字节之间的时间</li>
<li><code>upstream_response_time</code>：从连接上upstream开始到接受完 <code>upstream</code> 响应的最后一个字节之间的时间。</li>
</ul>
<p>从上面的定义可以看到， <code>request_time</code> 的值包含了接收用户请求数据、处理请求以及给用户发送响应这三部分的耗时，而 <code>upstream_response_time</code> 只是 <code>Nginx</code> 和上游服务交互的时间，在我们这里就是<code>PHP</code> 处理请求的时间。那么由于网络原因，<code>request_time</code> 大于甚至远大于<code>upstream_response_time</code> 都是很正常的，但是总是大5秒就很奇怪了。</p>
<h2 id="Nginx-配置导致的么？"><a href="#Nginx-配置导致的么？" class="headerlink" title="Nginx 配置导致的么？"></a><code>Nginx</code> 配置导致的么？</h2><p>因为两者总是相差5秒，很容易让人想到可能是Nginx的配置文件中的某个参数导致了该问题，通过查看配置文件确实发现了一个可疑的配置项目：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">fastcgi_connect_timeout</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<p>这个配置表示将 <code>Nginx</code> 与 <code>PHP-FPM</code> 之间的连接超时设置为5秒，那么导致该问题的一个可能的原因就是当 <code>Nginx</code> 第一次尝试与 <code>PHP-FPM</code> 建立连接超时了，第二次尝试才连上，这样就会正好多出了一个5秒的连接超时时间。可是进一步查看日志发现，<code>PHP</code> 的请求处理日志早在 <code>Nginx</code> 日志之前5秒就打出来了，而且如果 <code>Nginx</code> 连接 <code>PHP</code> 超时是会输出 <code>error</code> 日志的，但是线上的 <code>error</code> 日志里面并没有连接超时的记录，所以这个原因很快被否决了。</p>
<h2 id="Nagle-算法惹的祸？"><a href="#Nagle-算法惹的祸？" class="headerlink" title="Nagle 算法惹的祸？"></a>Nagle 算法惹的祸？</h2><p>既然配置文件中没有显式的配置会导致该问题，那么就有可能是 <code>Nginx</code> 的默认配置导致的，因此我搜索了一下源代码中与5有关的内容，希望能发现一些蛛丝马迹，结果发现了一段如下的注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Therefore we use the TCP_NOPUSH option (similar to Linux&apos;s TCP_CORK)</div><div class="line">to postpone the sending - it not only sends a header and the first part of</div><div class="line">the file in one packet, but also sends the file pages in the full packets.</div><div class="line"></div><div class="line">But until FreeBSD 4.5 turning TCP_NOPUSH off does not flush a pending</div><div class="line">data that less than MSS, so that data may be sent with 5 second delay.</div><div class="line">So we do not use TCP_NOPUSH on FreeBSD prior to 4.5, although it can be used</div><div class="line">for non-keepalive HTTP connections.</div></pre></td></tr></table></figure>
<p>上面注释的大概意思是，在较老的 <code>FreeBSD</code> 的操作系统上，就算关闭了 <code>TCP_NOPUSH</code> 参数，如果一个包小于 <code>MSS</code>，依然有可能会被延迟5秒发送。<code>TCP_NOPUSH</code> 参数是用来控制 <code>TCP</code> 的 <code>Nagle</code> 算法的，该算法的具体内容可以查阅网上资料，其核心思想是将多个连续的小包累积成一个大包，然后一次性发送，这可以提升网络的利用率。<code>Nginx</code> 中还有一个配置项也与 <code>Nagle</code> 算法相关，那就是 <code>TCP_NODELAY</code>，它的含义与 <code>TCP_NOPUSH</code> 正好相反，表示关闭 <code>TCP</code> 的 <code>Nagle</code> 化，也就是内核收到数据后不管大小直接发送。这两个配置看似互斥，但是在实际应用中，我们却将它们都打开，因为 <code>Nginx</code> 可以通过配合使用这两个配置来最大效率的利用网络。配合方式如下：首先根据 <code>TCP_NOPUSH</code> 开启 <code>Nagle</code> 算法，将数据累积到缓冲区中，当需要发送的数据都累积完成但是还没有达到 <code>MSS</code> 时，立即根据<code>TCP_NODELAY</code> 关闭 <code>Nagel</code> 算法，此时内核会一次性将缓冲区中的数据发出。总结为一句话就是：累积足够量的数据（<code>NOPUSH</code>）然后立即发出（<code>NODELAY</code>）。<br>我们线上的Linux内核版本是2.6.32，比较老了，所以我们猜想会不会也存在上面所说的这个问题，这时组内其他同学查看 <code>Nginx</code> 配置文件，发现 <code>sendfile</code>，<code>TCP_NOPUSH</code> 以及 <code>TCP_NODELAY</code> 这三个开关都打开了，但是 <code>Keep-Alive</code> 却没有打开，而 <code>Nginx</code> 手册中明确写到只有在开启 <code>sendfile</code> 的情况下 <code>TCP_NOPUSH</code> 才会生效，以及开启 <code>Keep-Alive</code> 的前提下 <code>TCP_NODELAY</code> 才会打开。换句话说，我们线上只开启了 <code>TCP_NOPUSH</code>，却没有开启 <code>TCP_NODELAY</code>，这就有可能导致包的延迟发送。因此我们联系了运维相关的同学，将 <code>Keep-Alive</code> 打开，也就是让 <code>TCP_NODELAY</code> 生效，然后观察日志，发现相差5秒的异常日志真的消失了。这时我们都以为问题的原因找到了。</p>
<h2 id="真的是Nagle算法惹的祸么？"><a href="#真的是Nagle算法惹的祸么？" class="headerlink" title="真的是Nagle算法惹的祸么？"></a>真的是Nagle算法惹的祸么？</h2><p>虽然开启 <code>Keep-Alive</code> 使 <code>TCP_NODELAY</code> 生效后，异常日志消失了，但是我心里依然有几个疑问，总觉得这不是导致问题的根本原因：</p>
<ol>
<li><code>Nagle</code> 算法是内核层面的，并不是Nginx实施的，也就是说累积包的过程是在内核中完成的，<code>Nginx</code> 只要把包写入到内核缓冲区后就会认为发送数据成功，然后直接记录日志，而不用等待这个累积的过程。</li>
<li><code>Nagle</code> 算法中累积超时一般设置的是200毫秒，就是说如果200毫秒还没能凑到一个 <code>MSS</code>，也会直接将缓冲区的内容发送出去，与5秒相距甚远。</li>
<li>如果是 <code>TCP_NODELAY</code> 关闭导致的原因，那么在开启 <code>Keep-Alive</code> 然后显式将 <code>TCP_NODELAY</code> 关闭的情况下，也应该会打出奇怪日志，可是我在线下并没能复现这一假设。</li>
</ol>
<h2 id="真正的原因：socket-lingering-close"><a href="#真正的原因：socket-lingering-close" class="headerlink" title="真正的原因：socket lingering close"></a>真正的原因：socket lingering close</h2><p>在几个猜想都不对后，觉得还是应该调试一下 <code>Nginx</code> 代码才能发现问题。因为担心直接 <code>gdb</code> 调试可能会导致 <code>Nginx</code> 的性能下降，以至于不能触发可以打出奇怪日志的条件，因此我想到了一个简单的变通方法：只要能获取计算 <code>request_time</code> 之前的所有函数调用栈，那么也就能够大致知道时间花在哪了。根据这个思路我修改了一下 <code>Nginx</code> 源代码，在获取时间的地方有意加了一个对内存的非法访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ngx_http_log_request_time(ngx_http_request_t *r, u_char *buf,</div><div class="line">    ngx_http_log_op_t *op)</div><div class="line">&#123;</div><div class="line">    ngx_time_t      *tp;</div><div class="line">    ngx_msec_int_t   ms;</div><div class="line">    tp = ngx_timeofday();</div><div class="line">    ms = (ngx_msec_int_t)</div><div class="line">             ((tp-&gt;sec - r-&gt;start_sec) * 1000 + (tp-&gt;msec - r-&gt;start_msec));</div><div class="line">    ms = ngx_max(ms, 0);</div><div class="line">    //如果响应时间是5s，就触发下面的内存访问错误，从而产生一个core。</div><div class="line">    if (ms == 5000) &#123;</div><div class="line">        *(char *)(0) = &apos;N&apos;;</div><div class="line">    &#125;</div><div class="line">    return ngx_sprintf(buf, &quot;%T.%03M&quot;, (time_t) ms / 1000, ms % 1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用修改后的代码，成功获取了一个 <code>core</code> ，根据 <code>core</code> 得到的调用栈如下：</p>
<p><img src="http://7xivjo.com1.z0.glb.clouddn.com/lingeringstack.png" alt="调用栈"></p>
<p>根据调用栈可以看到，在打日志之前，依次调用了三个红色框中的函数，它们都是用来处理连接关闭的。也就是说，在短连接的情况下，<code>Nginx</code> 只有在关闭与客户端的连接后才会开始输出日志，而不是给客户端发送完数据后就打日志。那么这个关闭连接的过程的耗时就很有可能是<code>request_time</code> 比 <code>upstream_response_time</code> 多出来的时间。我们接下来再来具体通过源代码看一下 <code>Nginx</code> 关闭连接的过程，主要的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">ngx_http_finalize_connection(ngx_http_request_t *r)</div><div class="line">&#123;</div><div class="line">    if (r-&gt;reading_body) &#123;</div><div class="line">        r-&gt;keepalive = 0;</div><div class="line">        r-&gt;lingering_close = 1;</div><div class="line">    &#125;</div><div class="line">    //如果开启了长连接且长连接未超时，那么走长连接处理相关的代码</div><div class="line">    if (!ngx_terminate</div><div class="line">         &amp;&amp; !ngx_exiting</div><div class="line">         &amp;&amp; r-&gt;keepalive</div><div class="line">         &amp;&amp; clcf-&gt;keepalive_timeout &gt; 0)</div><div class="line">    &#123;</div><div class="line">        ngx_http_set_keepalive(r);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    //不再需要keepalive，即连接需要关闭，并且打开了lingering close，就通过lingering close的方式来关闭连接，也就是延迟关闭</div><div class="line">    if (clcf-&gt;lingering_close == NGX_HTTP_LINGERING_ALWAYS</div><div class="line">        || (clcf-&gt;lingering_close == NGX_HTTP_LINGERING_ON</div><div class="line">            &amp;&amp; (r-&gt;lingering_close</div><div class="line">                || r-&gt;header_in-&gt;pos &lt; r-&gt;header_in-&gt;last</div><div class="line">                || r-&gt;connection-&gt;read-&gt;ready)))</div><div class="line">    &#123;</div><div class="line">        ngx_http_set_lingering_close(r);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ngx_http_close_request(r, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面并不是 <code>ngx_http_finalize_connection</code> 函数的全部，我只是贴出了与问题相关的代码。可以看到 <code>Nginx</code> 在不需要维护长连接且开启了 <code>lingering close</code> 的时，会调用 <code>ngx_http_set_lingering_close</code> 来设置最终的关闭函数。单词 <code>lingering</code> 是延迟的意思，那么 <code>lingering close</code> 自然是延迟关闭的意思。熟悉 <code>socket</code> 编程的同学应该知道 <code>socket</code> 有一个选项叫 <code>SO_LINGER</code>，如果对一个套接字开启了该选项，那么在调用 <code>close</code> 或者 <code>shutdown</code> 关闭套接字时会一直阻塞到将缓冲区里的消息都发送完毕才能返回。开启该选项的主要作用是为了平滑关闭套接字，使服务具有更好的兼容性，更具体的内容大家可以网上查阅资料。前面说到如果直接在套接字上设置 <code>SO_LINGER</code> 属性，那么在关闭时可能会引起阻塞，可是我们又知道 <code>Nginx</code> 里的套接字都设置了非阻塞属性，这会导致未定义的行为，另外如果完全由操作系统来进行延迟关闭，可能并不能满足 <code>Nginx</code> 的需求，所以 <code>Nginx</code> 没有使用这种方法，而是自己实现了延迟关闭。首先看下 <code>ngx_http_set_lingering_close</code> 函数，它是用来对一个请求设置延迟关闭方法的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">ngx_http_set_lingering_close(ngx_http_request_t *r)</div><div class="line">&#123;</div><div class="line">    ngx_event_t               *rev, *wev;</div><div class="line">    ngx_connection_t          *c;</div><div class="line">    ngx_http_core_loc_conf_t  *clcf;</div><div class="line">    c = r-&gt;connection;</div><div class="line">    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);</div><div class="line">    rev = c-&gt;read; //获取连接的读事件</div><div class="line">    //设置读事件触发时的处理函数，也就是延时关闭连接函数</div><div class="line">    rev-&gt;handler = ngx_http_lingering_close_handler;</div><div class="line">    //lingering_time用来控制总的延迟超时时间，比如在第一个lingering_timeout后，收到了数据，那么接下来还会再进行</div><div class="line">    //延迟关闭，然后再等待lingering_timeout，如此反复，但是总的时间不能超过lingering_time</div><div class="line">    r-&gt;lingering_time = ngx_time() + (time_t) (clcf-&gt;lingering_time / 1000);</div><div class="line">    //向事件循环中加入超时事件，超时时间是lingering_timeout，</div><div class="line">    //也就是说在lingering_timeout时间后，ngx_http_lingering_close_handler会被调用</div><div class="line">    ngx_add_timer(rev, clcf-&gt;lingering_timeout);</div><div class="line">    if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123;</div><div class="line">        ngx_http_close_request(r, 0);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    wev = c-&gt;write;</div><div class="line">    wev-&gt;handler = ngx_http_empty_handler;</div><div class="line">    if (wev-&gt;active &amp;&amp; (ngx_event_flags &amp; NGX_USE_LEVEL_EVENT)) &#123;</div><div class="line">        if (ngx_del_event(wev, NGX_WRITE_EVENT, 0) != NGX_OK) &#123;</div><div class="line">            ngx_http_close_request(r, 0);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //关闭套接字的写端，也就是说只有读是延迟关闭的</div><div class="line">    if (ngx_shutdown_socket(c-&gt;fd, NGX_WRITE_SHUTDOWN) == -1) &#123;</div><div class="line">        ngx_connection_error(c, ngx_socket_errno,</div><div class="line">                             ngx_shutdown_socket_n &quot; failed&quot;);</div><div class="line">        ngx_http_close_request(r, 0);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (rev-&gt;ready) &#123;</div><div class="line">        ngx_http_lingering_close_handler(rev);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ngx_http_set_lingering_close</code> 函数就是用过来设置延迟关闭函数的，关键的部分已经加了注释。可以看到 <code>Nginx</code> 主要通过 <code>lingering_time</code> 和 <code>lingering_timeout</code> 这两个参数来控制延迟关闭的时间，<code>lingering_time</code> 表示总的延迟时间，<code>lingering_timeout</code> 表示单次延迟时间。上面的这段代码会向 <code>Nginx</code> 的事件循环注册一个超时时间，超时的时间间隔是 <code>lingering_timeout</code> ，超时事件的处理函数是 <code>ngx_http_lingering_close_handler</code>，就是说一旦延迟时间到了，该函数就会被调用，它的主要内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">ngx_http_lingering_close_handler(ngx_event_t *rev)</div><div class="line">&#123;</div><div class="line">    ssize_t                    n;</div><div class="line">    ngx_msec_t                 timer;</div><div class="line">    ngx_connection_t          *c;</div><div class="line">    ngx_http_request_t        *r;</div><div class="line">    ngx_http_core_loc_conf_t  *clcf;</div><div class="line">    u_char                     buffer[NGX_HTTP_LINGERING_BUFFER_SIZE];</div><div class="line"> </div><div class="line">    c = rev-&gt;data;</div><div class="line">    r = c-&gt;data;</div><div class="line"> </div><div class="line">    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0,</div><div class="line">                   &quot;http lingering close handler&quot;);</div><div class="line"> </div><div class="line">    if (rev-&gt;timedout) &#123;</div><div class="line">        ngx_http_close_request(r, 0);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    //计算剩余的全部可用超时时间</div><div class="line">    timer = (ngx_msec_t) r-&gt;lingering_time - (ngx_msec_t) ngx_time();</div><div class="line">    //总延迟等待时间已经超过lingering_time了，那么不管怎么样都直接关闭连接</div><div class="line">    if ((ngx_msec_int_t) timer &lt;= 0) &#123;</div><div class="line">        ngx_http_close_request(r, 0);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    do &#123;</div><div class="line">        n = c-&gt;recv(c, buffer, NGX_HTTP_LINGERING_BUFFER_SIZE);</div><div class="line"> </div><div class="line">        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, c-&gt;log, 0, &quot;lingering read: %z&quot;, n);</div><div class="line">        //延迟时间到了，且套接字发生了错误，或者对方关闭了套接字，那么将整个连接关闭</div><div class="line">        if (n == NGX_ERROR || n == 0) &#123;</div><div class="line">            ngx_http_close_request(r, 0);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">    &#125; while (rev-&gt;ready);</div><div class="line"> </div><div class="line">    if (ngx_handle_read_event(rev, 0) != NGX_OK) &#123;</div><div class="line">        ngx_http_close_request(r, 0);</div><div class="line"> </div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);</div><div class="line"> </div><div class="line">    timer *= 1000;</div><div class="line">     </div><div class="line">    if (timer &gt; clcf-&gt;lingering_timeout) &#123;</div><div class="line">        timer = clcf-&gt;lingering_timeout;</div><div class="line">    &#125;</div><div class="line">    //运行到这里，说明超时时间内客户端发来了数据且还有超时时间可用，那么来再次注册延迟关闭事件，开始下一次的延迟关闭等待。</div><div class="line">    ngx_add_timer(rev, timer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是当延迟关闭事件超时后 <code>Nginx</code> 的处理过程，首先计算总的延迟超时时间还剩余多少，如果没有了，直接断开连接，这可以防止『等待-接收部分数据-等待-接收部分数据』的无限死循环。接下来 <code>Nginx</code> 尝试读取套接字，如果读出错或者对方关闭了连接或者依然没有数据读到，那么 <code>Nginx</code> 就将连接关闭，否则再次注册延迟超时事件，开始下一次的延迟关闭。根据上面的分析可以看到，在 <code>Nginx</code> 发送完数据包并进入延迟关闭连接流程后，如果客户端在 <code>lingering_timeout</code> 时间内没有进行任何操作，那么就会关闭与客户端的连接然后输出日志，这就会导致导致访问日志滞后 <code>lingering_timeout</code> 才输出。我们线上并没有对该参数进行配置，那么会采用默认值，正好是5秒，与实际情况吻合。另外如果使用长连接，<code>Nignx</code> 在请求结束后不需要关闭连接而直接输出日志，那么就不会有这个问题，这也就解释了为什么开启 <code>Keep-Alive</code> 后问题消失。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>知道了问题的原因复现就很简单了，只要在 <code>Nginx</code> 中设置 <code>lingering_timeout</code> 的值，然后观察日志中输出的时间差是不是发生相应的改变即可。比如将该值设置为7，会发现时间差为5的日志就消失了，而都变成了时间差为7的日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[shibing@localhost sbin]$ tail -f ../logs/access.log  | grep &quot;request_time=7&quot;</div><div class="line">172.17.176.138 - - [17/Nov/2016:18:53:15 +0800] &quot;GET /index.php HTTP/1.1&quot; 200 3450 &quot;-&quot; &quot;-&quot; &quot;-&quot; request_time=7.001 upstream_time=0.000 header_time=0.000</div><div class="line">172.17.176.138 - - [17/Nov/2016:18:53:15 +0800] &quot;GET /index.php HTTP/1.1&quot; 200 3450 &quot;-&quot; &quot;-&quot; &quot;-&quot; request_time=7.000 upstream_time=0.000 header_time=0.000</div><div class="line">172.17.176.138 - - [17/Nov/2016:18:53:15 +0800] &quot;GET /index.php HTTP/1.1&quot; 200 3450 &quot;-&quot; &quot;-&quot; &quot;-&quot; request_time=7.001 upstream_time=0.001 header_time=0.001</div><div class="line">172.17.176.138 - - [17/Nov/2016:18:53:15 +0800] &quot;GET /index.php HTTP/1.1&quot; 200 3450 &quot;-&quot; &quot;-&quot; &quot;-&quot; request_time=7.000 upstream_time=0.000 header_time=0.000</div><div class="line">172.17.176.138 - - [17/Nov/2016:18:53:15 +0800] &quot;GET /index.php HTTP/1.1&quot; 200 3450 &quot;-&quot; &quot;-&quot; &quot;-&quot; request_time=7.000 upstream_time=0.000 header_time=0.000</div><div class="line">172.17.176.138 - - [17/Nov/2016:18:53:15 +0800] &quot;GET /index.php HTTP/1.1&quot; 200 3450 &quot;-&quot; &quot;-&quot; &quot;-&quot; request_time=7.000 upstream_time=0.000 header_time=0.000</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://shibing.github.io/2016/09/30/nginx内存对齐/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Bing Shi">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stone's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stone's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/30/nginx内存对齐/" itemprop="url">
                  nginx内存对齐
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-30T21:50:57+08:00">
                2016-09-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/09/30/nginx内存对齐/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/30/nginx内存对齐/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在看<code>Nginx</code>的源代码，阅读其有关内存池实现的时候发现下面一段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (align) &#123;</div><div class="line">	m = ngx_align_ptr(m, NGX_ALIGNMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码的意图很明显，就是将指针<code>m</code>按照<code>NGX_ALIGNMENT</code>大小进行对齐，那么它是如何进行对齐的呢？关键就在<code>ngx_align_ptr</code>，它其实是个宏，定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define ngx_align_ptr(p, a)                                                   \</div><div class="line">    (u_char *) (((uintptr_t) (p) + ((uintptr_t) a - 1)) &amp; ~((uintptr_t) a - 1))</div></pre></td></tr></table></figure>
<p>我刚看到这个宏的时候觉得很神奇，完全不知道它进行内存对齐的原理是什么。于是打算人肉运行一下这段代码，看能不能发现里面的玄机。</p>
<p>首先类型转换都去掉，这样代码能看的清楚一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(p + (a - 1)) &amp; ~(a-1)</div></pre></td></tr></table></figure>
<p>在进行内存的对齐的时候，一般都是将地址按<code>2</code>的幂进行对齐，也就是说<code>a</code>的末尾必然由0组成。假设有<code>N</code>个0，那么将<code>a</code>减去一后，就得到了一个末尾有<code>N</code>个<code>1</code>其他位都是<code>0</code>的数，再取反的话就变成了末尾有<code>N</code>个0，其他位都是<code>1</code>的数。那么再将这个数与任何数相与都将把被与数的最后<code>N</code>位变成<code>0</code>而其他位置不变，而这个数正是<code>a</code>的整数倍。那么加上<code>a-1</code>的目的是什么呢？很明显是为了最后得到的数要比<code>p</code>大，不然后的话，分配的内存就可能占用了别的已分配空间。</p>
<p>另外上面在进行运算之前将所有的变量都转换成了<code>uintptr_t</code>类型，该类型本质上也是个整型，但是该整型的大小能够安全的容纳指针变量，相比于直接用整数类型而言更加具有可移植性和安全性。</p>
<p>（完）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://shibing.github.io/2016/08/20/动态链接与rpath/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Bing Shi">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/uploads/avatar.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Stone's Blog">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Stone's Blog" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/20/动态链接与rpath/" itemprop="url">
                  动态链接与rpath
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-20T12:57:50+08:00">
                2016-08-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/08/20/动态链接与rpath/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/20/动态链接与rpath/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在工作中做<code>php</code>环境的绿色安装，所谓绿色安装是指将程序以及它的所有依赖包括一些共享库、配置文件等打包到一起然后进行安装的方式。因为所有的依赖都打包到了一起，那么部署的过程其实就是简单的拷贝过程，非常的方便。但是这之中遇到了一个问题，就是如何让<code>php</code>运行的时候加载我们绿色包里面的共享库，而不是加载系统自身的共享库。为此学习了<code>linux</code>下运行时链接器器搜索共享库的方式，发现通过指定<code>RPATH</code>可以很方便的解决这个问题。</p>
<h1 id="RPATH"><a href="#RPATH" class="headerlink" title="RPATH"></a><code>RPATH</code></h1><p>linux下在链接共享库的时候可以通过<code>rpath</code>选项来指定<strong>运行时</strong>共享库加载路径。 通过这个选项指定的路径会写到ELF文件<code>dynamic</code>段的<code>RPATH</code>里, 运行时链接器会在此路径下搜索ELF文件所依赖的共享库。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>假设我们有一个共享库<code>libarith.so</code>，提供了常见的算术运算，它由<code>arith.h</code>与<code>arith.c</code>两个文件编译生成。内容如下：</p>
<p><code>arith.h</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</div></pre></td></tr></table></figure></p>
<p><code>arith.c</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"arith.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成<code>so</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -fPIC -shared arith.c -o libarith.so</div></pre></td></tr></table></figure></p>
<p>然后我们有一个<code>main.c</code>文件需要调用前面生成的共享库，内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"arith.h"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    add(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们不指定<code>rpath</code>直接编译<code>main.c</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -L. -larith main.c -o main</div></pre></td></tr></table></figure></p>
<p>编译后目录内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── arith.c</div><div class="line">├── arith.h</div><div class="line">├── libarith.so</div><div class="line">├── main</div><div class="line">└── main.c</div></pre></td></tr></table></figure></p>
<p>若此时运行<code>main</code>文件会报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./main: error while loading shared libraries: libarith.so: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure></p>
<p>报错提示找不到<code>libarith.so</code>文件。该文件在我们当前目录下，但是当前目录并不在运行时链接器的搜索路径中。一种解决办法是将当前路径添加到<code>LD_LIBRARY_PATH</code>中，但是该方法是一种全局配置，总是显得不那么干净。下面介绍第二种方法，就是在链接的时候直接将搜索路径写到RPATH中，按如下方式重新编译：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -L. -larith main.c -Wl,-rpath=&apos;.&apos; -o main</div></pre></td></tr></table></figure></p>
<p><code>-rpath</code>是链接器选项，并不是<code>gcc</code>的编译选项，所以上面通过<code>-Wl,</code>告知编译器将此选项传给下一阶段的链接器。重新编译后，采用<code>readelf</code>命令查看<code>main</code>文件的<code>dynamic</code>节，发现多了一个<code>RPATH</code>字段，且值就是我们前面设置的路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ readelf -d main| grep PATH</div><div class="line">  0x000000000000000f (RPATH)              Library rpath: [.]</div></pre></td></tr></table></figure></p>
<p>再次尝试运行<code>main</code>文件会发现一切正常。</p>
<h1 id="ORIGIN"><a href="#ORIGIN" class="headerlink" title="$ORIGIN"></a><code>$ORIGIN</code></h1><p>上面的解决办法还有一些小问题，<code>RPATH</code>指定的路径是相当于当前目录的，而不是相对于可执行文件所在的目录，那么当换一个目录再执行上面的程序，就会又报找不到共享库。解决这个问题的办法就是使用<code>$ORIGIN</code>变量，在运行的时候，链接器会将该变量的值用可执行文件所在的目录来替换，这样我们就又能相对于可执行文件来指定<code>RPATH</code>了。重新编译如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -L. -larith main.c -Wl,-rpath=&apos;$ORIGIN/&apos; -o main</div></pre></td></tr></table></figure></p>
<h1 id="patchelf命令"><a href="#patchelf命令" class="headerlink" title="patchelf命令"></a><code>patchelf命令</code></h1><p>很多时候我们拿到的是编译好的二进制文件，这样我们就不能用前面的办法来指定<code>RPATH</code>了。幸好有<code>patchelf</code>这个小工具，它可以用来修改<code>elf</code>文件，用它修改<code>main</code>的<code>RPATH</code>的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pathelf  main --set-rpath=&apos;$ORIGIN/&apos;</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面介绍了<code>RPATH</code>的作用，如何在编译的时候通过相关参数指定<code>RPATH</code>，以及使用<code>patchelf</code>修改<code>RPATH</code>的方法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.png"
               alt="Bing Shi" />
          <p class="site-author-name" itemprop="name">Bing Shi</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/shibing" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bing Shi</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"stone-sw"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  

  

  

  

  


</body>
</html>
